use miden_crypto::StarkField;
use miden_processor::{Operation, ProgramInfo, StackOutputs};
use miden_prover::{ExecutionProof, ProofOptions};
use miden_verifier::VerificationError;
use serde::{Deserialize, Serialize};

use crate::{
    batch::Batch,
    hash::{Digest, Hashable},
};

use super::utils;

mod advice;
mod program;
mod serde_impls;
mod stack;

/// A proof that a particular hash was actually generated by hashing a [`Batch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BatchHashProof {
    /// The actual proof generated by miden
    #[serde(with = "serde_impls")]
    proof: ExecutionProof,

    /// The number of operations in the batch - this is needed since it is part of the stack
    /// inputs, which are required to verify the execution
    op_count: u64,

    /// The hash of the batch
    hash: Digest,
}

impl BatchHashProof {
    /// The hash of the batch that was proven
    #[inline]
    #[must_use]
    pub fn hash(&self) -> Digest {
        self.hash
    }

    /// Verify the validity of this proof
    ///
    /// If this function succeeds, it returns the security level of the proof
    pub fn verify(&self) -> Result<u32, VerificationError> {
        let program = program::program();
        let program = ProgramInfo::new(program.hash(), program.kernel().clone());

        let input = stack::make_stack(self.op_count);
        let output = StackOutputs::new(self.hash.to_elements().map(|f| f.inner()).to_vec(), vec![]);

        miden_verifier::verify(program, input, output, self.proof.clone())
    }
}

pub(crate) fn prove_batch_hash<K, V>(batch: &Batch<K, V>) -> BatchHashProof
where
    K: Hashable,
    V: Hashable,
{
    let op_count = batch.operations().len() as u64;

    let program = program::program();
    let advice = advice::make_advice(batch);
    let stack = stack::make_stack(op_count);
    let options = ProofOptions::default();

    let (output, proof) = miden_prover::prove(program, stack, advice, options).unwrap();

    let hash = utils::hash_from_stack_output(&output);

    BatchHashProof {
        proof,
        op_count,
        hash,
    }
}

pub(crate) fn debug_batch_hash<K, V>(batch: &Batch<K, V>)
where
    K: Hashable,
    V: Hashable,
{
    let op_count = batch.operations().len() as u64;

    let program = program::program();
    let advice = advice::make_advice(batch);
    let stack = stack::make_stack(op_count);

    let iter = miden_processor::execute_iter(program, stack, advice);

    for (i, state) in iter.enumerate() {
        let state = state.unwrap();
        let stack: Vec<_> = state.stack.iter().copied().map(|f| f.as_int()).collect();
        let op = state.op.as_ref().copied().unwrap_or(Operation::Noop);
        println!("step {i:0>4}: ({op}) {stack:?}");
    }
}

#[cfg(test)]
#[allow(clippy::explicit_deref_methods)]  // bug in test_strategy
mod tests {
    use test_strategy::proptest;

    use crate::batch::{proptest::batch, Operation};

    use super::*;

    #[test]
    fn simple_batch_hash_and_prove() {
        // .hash_and_prove() panics if anything goes wrong

        let _ = Batch::<i32, String>::from_operations(vec![]).hash_and_prove();

        let batch = Batch::from_operations(vec![
            Operation::Insert(123, "foo"),
        ]);
        let _ = batch.hash_and_prove();

        let batch = Batch::from_operations(vec![
            Operation::Insert(123, "foo"),
            Operation::Insert(234, "bar"),
        ]);
        let _ = batch.hash_and_prove(); 

    }

    #[proptest(cases = 10)]
    fn any_batch_can_prove_itself(#[strategy(batch(0..50))] batch: Batch<i32, String>) {
        let proof = batch.hash_and_prove();
        proof.verify().unwrap();
    }
}
